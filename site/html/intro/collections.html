<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Collections &mdash; Tart v0.1.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Tart v0.1.1 documentation" href="../index.html" />
    <link rel="up" title="Introduction to Tart" href="index.html" />
    <link rel="next" title="Classes" href="classes.html" />
    <link rel="prev" title="Function Type Expressions" href="functions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="collections">
<span id="index-8"></span><h1>Collections<a class="headerlink" href="#collections" title="Permalink to this headline">¶</a></h1>
<p>The Tart core library contains a rich set of collection classes which include a variety of sequence,
map, and set collections.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Collection Class</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="xref docutils literal"><span class="pre">Collection</span></tt></td>
<td>Interface for collections that can be enumerated and appended.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">List</span></tt></td>
<td>Interface for appendable sequences.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">Map</span></tt></td>
<td>Interface for map types.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">Set</span></tt></td>
<td>Interface for set types.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">Array</span></tt></td>
<td>A fixed-length array of elements.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">ArrayList</span></tt></td>
<td>A list which is backed by an array.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">ImmutableList</span></tt></td>
<td>A read-only List.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">ImmutableMap</span></tt></td>
<td>A read-only map.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">ImmutableSet</span></tt></td>
<td>A read-only set.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">HashMap</span></tt></td>
<td>A map that is implemented by a hash table.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">HashSet</span></tt></td>
<td>A set that is implemented by a hash table.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">EnumSet</span></tt></td>
<td>A set whose values are restricted to a given enumeration.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">EnumMap</span></tt></td>
<td>A map whose keys are restricted to a given enumeration.</td>
</tr>
</tbody>
</table>
<p class="graphviz">
<img src="../_images/graphviz-68017e384540e4158139355ec299e7fc6872fbf2.png" alt="digraph foo {
ranksep = 0.5;
node [shape=&quot;box&quot;, fontsize=9, height=.3, margin=&quot;0.2,0.1&quot;];
edge [dir=back];

&quot;Collection&quot; -&gt; &quot;Array&quot;;
&quot;Collection&quot; -&gt; &quot;List&quot;;
&quot;Collection&quot; -&gt; &quot;Set&quot;;
&quot;Collection&quot; -&gt; &quot;Map&quot;;
&quot;List&quot; -&gt; &quot;ArrayList&quot;;
&quot;List&quot; -&gt; &quot;ImmutableList&quot;;
&quot;Map&quot; -&gt; &quot;ImmutableMap&quot;;
&quot;Map&quot; -&gt; &quot;HashMap&quot;;
&quot;Map&quot; -&gt; &quot;EnumMap&quot;;
&quot;Set&quot; -&gt; &quot;ImmutableSet&quot;;
&quot;Set&quot; -&gt; &quot;HashSet&quot;;
&quot;Set&quot; -&gt; &quot;EnumSet&quot;;
&quot;Collection&quot; [peripheries=2]
&quot;List&quot; [peripheries=2]
&quot;Set&quot; [peripheries=2]
&quot;Map&quot; [peripheries=2]
}" />
</p>
<p>See the <a class="reference" href="../lib/collections/index.html#collections-library"><em>tart.collections - common collection classes</em></a> section for more information about the collection classes.</p>
<div class="section" id="collection-literal-syntax">
<span id="index-9"></span><h2>Collection Literal Syntax<a class="headerlink" href="#collection-literal-syntax" title="Permalink to this headline">¶</a></h2>
<p>All of the list and set collections in the core collections library have a constructor which takes
a variable-length list of initializers:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// ArrayList of integers</span>
<span class="k">let</span> <span class="nv">a0</span> <span class="o">=</span> <span class="nv">ArrayList</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>

<span class="c">// Immutable list of strings.</span>
<span class="k">let</span> <span class="nv">a1</span> <span class="o">=</span> <span class="nv">ImmutableList</span><span class="p">(</span><span class="s">&quot;Hydrogen&quot;</span><span class="p">,</span> <span class="s">&quot;Helium&quot;</span><span class="p">,</span> <span class="s">&quot;Lithium&quot;</span><span class="p">);</span>

<span class="c">// Hash set of strings, with explicitly specified type.</span>
<span class="k">let</span> <span class="nv">a2</span> <span class="o">=</span> <span class="nv">HashSet</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Clubs&quot;</span><span class="p">,</span> <span class="s">&quot;Spades&quot;</span><span class="p">,</span> <span class="s">&quot;Hearts&quot;</span><span class="p">,</span> <span class="s">&quot;Diamonds&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>In most cases, the type of the collection can be deduced either from the items in the initializer
list, or the type of the variable being assigned to (if specified). However, you can also specify
the type explicitly, as seen in the last line in the previous example.</p>
<p>In some cases, the collection takes additional parameters as keyword-only arguments:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// ArrayList of integers with initial size 3, reserved size 10.</span>
<span class="k">let</span> <span class="nv">a0</span> <span class="o">=</span> <span class="nv">ArrayList</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="nv">reserve</span><span class="o">=</span><span class="mf">10</span><span class="p">);</span>
</pre></div>
</div>
<p>There is also a shortcut syntax, which can be used when the list type is deducible:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">a0</span><span class="p">:</span><span class="nc">int</span><span class="p">[]</span> <span class="o">=</span> <span class="k">{</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="k">}</span><span class="p">;</span>
<span class="k">let</span> <span class="nv">a1</span><span class="p">:</span><span class="nc">ImmutableList</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">{</span><span class="s">&quot;Hydrogen&quot;</span><span class="p">,</span> <span class="s">&quot;Helium&quot;</span><span class="p">,</span> <span class="s">&quot;Lithium&quot;</span><span class="k">}</span><span class="p">;</span>
<span class="k">let</span> <span class="nv">a1</span><span class="p">:</span><span class="nc">HashSet</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">{</span><span class="s">&quot;Clubs&quot;</span><span class="p">,</span> <span class="s">&quot;Spades&quot;</span><span class="p">,</span> <span class="s">&quot;Hearts&quot;</span><span class="p">,</span> <span class="s">&quot;Diamonds&quot;</span><span class="k">}</span><span class="p">;</span>
</pre></div>
</div>
<p>The initializer-list syntax (consisting of a comma-separated list, surrounded by braces) is
automatically transformed by the compiler into the corresponding constructor call. This also
works for function arguments:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="nv">childNodes</span><span class="p">:</span><span class="nc">List</span><span class="gr">&lt;Element&gt;</span><span class="p">);</span>

<span class="nv">append</span><span class="p">(</span><span class="k">{</span>
  <span class="nv">SpanElement</span><span class="p">(),</span>
  <span class="nv">AnchorElement</span><span class="p">(),</span>
  <span class="nv">DivElement</span><span class="p">()</span><span class="k">}</span><span class="p">);</span>
</pre></div>
</div>
<p>However, in most cases it is simpler to use variadic arguments:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="nv">childNodes</span><span class="p">:</span><span class="nc">Element</span><span class="gr">...</span><span class="p">);</span>

<span class="nv">append</span><span class="p">(</span>
  <span class="nv">SpanElement</span><span class="p">(),</span>
  <span class="nv">AnchorElement</span><span class="p">(),</span>
  <span class="nv">DivElement</span><span class="p">());</span>
</pre></div>
</div>
<p>The list and set classes also have a <tt class="xref docutils literal"><span class="pre">from()</span></tt> method, which takes an Iterable instead of
a list of items:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Fill up an array with the squares of the numbers from 0 to 9.</span>
<span class="k">let</span> <span class="nv">a0</span> <span class="o">=</span> <span class="nv">ArrayList</span><span class="o">.</span><span class="nv">from</span><span class="p">(</span><span class="nv">x</span> <span class="o">*</span> <span class="nv">x</span> <span class="k">for</span> <span class="nv">x</span> <span class="k">in</span> <span class="mf">0</span> <span class="o">..</span> <span class="mf">10</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="map-literals">
<span id="index-10"></span><h2>Map Literals<a class="headerlink" href="#map-literals" title="Permalink to this headline">¶</a></h2>
<p>Map literals are handled a little differently, because the key and the value may not be the same
type. The <tt class="xref docutils literal"><span class="pre">-&gt;</span></tt> operator is used to indicate a key/value pair. This special meaning of the
<tt class="xref docutils literal"><span class="pre">-&gt;</span></tt> operator is only valid within a map initializer list - otherwise it is used to indicate
a function return type.</p>
<blockquote>
<dl class="docutils">
<dt>let f:HashMap = {</dt>
<dd>&#8220;Apple&#8221; -&gt; 1,
&#8220;Cherry&#8221; -&gt; 2,
&#8220;Lemon&#8221; -&gt; 3 };</dd>
</dl>
</blockquote>
<p>This is translated by the compiler into the following code:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">f</span><span class="p">:</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nv">HashMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nv">HashMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;.</span><span class="nv">Entry</span><span class="p">(</span><span class="s">&quot;Apple&quot;</span><span class="p">,</span> <span class="mf">1</span><span class="p">),</span>
  <span class="nv">HashMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;.</span><span class="nv">Entry</span><span class="p">(</span><span class="s">&quot;Cherry&quot;</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span>
  <span class="nv">HashMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;.</span><span class="nv">Entry</span><span class="p">(</span><span class="s">&quot;Lemon&quot;</span><span class="p">,</span> <span class="mf">3</span><span class="p">));</span>
</pre></div>
</div>
<p>In other words, it converts the initializer list into an array of &#8220;Entry&#8221; structures, each
containing a key/value pair, which is then passed to the map&#8217;s constructor. The collection
may or may not actually use the &#8220;Entry&#8221; class internally - it is free to choose whatever internal
representation is convenient.</p>
</div>
<div class="section" id="generator-expressions-and-comprehensions">
<span id="index-11"></span><h2>Generator expressions and comprehensions<a class="headerlink" href="#generator-expressions-and-comprehensions" title="Permalink to this headline">¶</a></h2>
<p>Tart supports &#8220;generator expressions&#8221; similar to those found in Python. A generator expression
produces an iterator, which can be passed directly to the <tt class="xref docutils literal"><span class="pre">from()</span></tt> method of a collection:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">s0</span> <span class="o">=</span> <span class="nv">ImmutableSet</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">&gt;.</span><span class="nv">from</span><span class="p">(</span><span class="nv">x</span> <span class="o">*</span> <span class="nv">x</span> <span class="k">for</span> <span class="nv">x</span> <span class="k">in</span> <span class="mf">0</span> <span class="o">..</span> <span class="mf">10</span><span class="p">);</span>
</pre></div>
</div>
<p>The initializer-list syntax is also supported, as is the map key/value operator:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">s0</span><span class="p">:</span><span class="nc">ImmutableSet</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">{</span><span class="nv">x</span> <span class="o">*</span> <span class="nv">x</span> <span class="k">for</span> <span class="nv">x</span> <span class="k">in</span> <span class="mf">0</span> <span class="o">..</span> <span class="mf">10</span><span class="k">}</span><span class="p">;</span>
<span class="k">let</span> <span class="nv">m0</span><span class="p">:</span><span class="nc">ImmutableMap</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">{</span><span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">x</span> <span class="o">*</span> <span class="nv">x</span> <span class="k">for</span> <span class="nv">x</span> <span class="k">in</span> <span class="mf">0</span> <span class="o">..</span> <span class="mf">10</span><span class="k">}</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="sequence-unpacking">
<h2>Sequence Unpacking<a class="headerlink" href="#sequence-unpacking" title="Permalink to this headline">¶</a></h2>
<p>Tart supports a Python-like ability to unpack variables from a sequence:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">a</span><span class="p">,</span> <span class="nv">b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">];</span>
<span class="k">let</span> <span class="nv">a</span><span class="p">:</span><span class="nc">int</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span><span class="nc">int</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">];</span>
</pre></div>
</div>
<p>The last variable in the unpacking assignment can be a variadic argument, meaning it scoops up all
the remaining values:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">let</span> <span class="nv">a</span><span class="p">:</span><span class="nc">int</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span><span class="nc">int</span><span class="o">...</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">];</span>
</pre></div>
</div>
<p>As with function arguments, the &#8216;...&#8217; syntax changes the type of the argument into an array of the
explicitly declared type. So the type of <tt class="docutils literal"><span class="pre">b</span></tt> is actually <tt class="docutils literal"><span class="pre">int[]</span></tt>, and would in the above example
be assigned the value <tt class="docutils literal"><span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">4]</span></tt>.</p>
<p>Variable unpacking works with regular assignment as well, allowing for the Python &#8216;swap idiom&#8217; to
exchange the values of two variables:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span> <span class="o">=</span> <span class="nv">b</span><span class="p">,</span> <span class="nv">a</span><span class="p">;</span>
</pre></div>
</div>
<p>The sequence-unpacking syntax is what allows you to return multiple values from a function:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">def</span> <span class="nf">returnStringAndInt</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="k">{</span>
  <span class="k">return</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="mf">12</span><span class="p">;</span>
<span class="k">}</span>

<span class="k">let</span> <span class="nv">a</span><span class="p">:</span><span class="nc">String</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span><span class="nc">int</span> <span class="o">=</span> <span class="nv">returnStringAndInt</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike Python, a function that returns multiple values does not actually
create a &#8216;tuple&#8217; object for the return results. Instead, the values are returned
either in registers or on the stack - the exact mechanism is dependent on the
platform ABI.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference" href="">Collections</a><ul>
<li><a class="reference" href="#collection-literal-syntax">Collection Literal Syntax</a></li>
<li><a class="reference" href="#map-literals">Map Literals</a></li>
<li><a class="reference" href="#generator-expressions-and-comprehensions">Generator expressions and comprehensions</a></li>
<li><a class="reference" href="#sequence-unpacking">Sequence Unpacking</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="functions.html"
                                  title="previous chapter">Function Type Expressions</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="classes.html"
                                  title="next chapter">Classes</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/intro/collections.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes"
             >next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             >previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Talin.
      Last updated on Jul 23, 2009.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
    </div>
  </body>
</html>